diff --git a/src/platform/mpfs_hal/common/mss_mtrap.c b/src/platform/mpfs_hal/common/mss_mtrap.c
index 150a449..3672e72 100644
--- a/src/platform/mpfs_hal/common/mss_mtrap.c
+++ b/src/platform/mpfs_hal/common/mss_mtrap.c
@@ -1,10 +1,6 @@
 /*******************************************************************************
- * Copyright 2019-2020 Microchip FPGA Embedded Systems Solutions.
- *
- * SPDX-License-Identifier: MIT
- *
- * MPFS HAL Embedded Software
- *
+ * See LICENSE for license details.
+ * Modifications copyright (C) 2021 Hex Five Security, Inc.
  */
 
 /***************************************************************************
@@ -32,6 +28,13 @@ void pmp_trap(uintptr_t * regs, uintptr_t mcause, uintptr_t mepc);
 void trap_from_machine_mode(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc);
 void bad_trap(uintptr_t* regs, uintptr_t dummy, uintptr_t mepc);
 
+void handle_m_trap_h0(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h1(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h2(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h3(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h4(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+
 
 void bad_trap(uintptr_t* regs, uintptr_t dummy, uintptr_t mepc)
 {
@@ -748,34 +751,65 @@ void trap_from_machine_mode(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc)
     }
     else
     {
-        uint32_t i;
-        while(1)
-        {
-            /* wait for watchdog */
-            i++;        /* added some code as SC debugger hangs if in loop doing nothing */
-            if(i == 0x1000U)
-            {
-                i = 0U;
-            }
+
+        switch(read_csr(mhartid)) {
+        case 0U: handle_m_trap_h0(regs, mcause, mepc); break;
+        case 1U: handle_m_trap_h1(regs, mcause, mepc); break;
+        case 2U: handle_m_trap_h2(regs, mcause, mepc); break;
+        case 3U: handle_m_trap_h3(regs, mcause, mepc); break;
+        case 4U: handle_m_trap_h4(regs, mcause, mepc); break;
+        default: handle_m_trap(regs, mcause, mepc);
         }
-        switch(mcause)
-        {
 
-            case CAUSE_LOAD_PAGE_FAULT:
-                break;
-            case CAUSE_STORE_PAGE_FAULT:
-                break;
-            case CAUSE_FETCH_ACCESS:
-                break;
-            case CAUSE_LOAD_ACCESS:
-                break;
-            case CAUSE_STORE_ACCESS:
-                break;
-            default:
-                bad_trap(regs, dummy, mepc);
-                break;
+    }
+
+}
+
+__attribute__((weak)) void handle_m_trap_h0(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h1(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h2(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h3(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h4(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+
+void handle_m_trap(uintptr_t * regs, uintptr_t mcause, uintptr_t mepc) /* Hex Five mod */
+{
+    uint32_t i;
+    while(1)
+    {
+        /* wait for watchdog */
+        i++;        /* added some code as SC debugger hangs if in loop doing nothing */
+        if(i == 0x1000U)
+        {
+            i = 0U;
         }
     }
+    switch(mcause)
+    {
+
+        case CAUSE_LOAD_PAGE_FAULT:
+            break;
+        case CAUSE_STORE_PAGE_FAULT:
+            break;
+        case CAUSE_FETCH_ACCESS:
+            break;
+        case CAUSE_LOAD_ACCESS:
+            break;
+        case CAUSE_STORE_ACCESS:
+            break;
+        default:
+            bad_trap(regs, mcause, mepc);
+            break;
+    }
 }
 
 #ifdef __cplusplus
diff --git a/src/platform/mpfs_hal/startup_gcc/mss_entry.S b/src/platform/mpfs_hal/startup_gcc/mss_entry.S
index 9e049de..989b718 100644
--- a/src/platform/mpfs_hal/startup_gcc/mss_entry.S
+++ b/src/platform/mpfs_hal/startup_gcc/mss_entry.S
@@ -1,10 +1,6 @@
 /*******************************************************************************
- * Copyright 2019-2020 Microchip Corporation.
- *
- * SPDX-License-Identifier: MIT
- *
- * MPFS HAL Embedded Software
- *
+ * See LICENSE for license details.
+ * Modifications copyright (C) 2021 Hex Five Security, Inc.
  */
 
 /*******************************************************************************
@@ -55,7 +51,7 @@ _start:
     csrw medeleg, 0
 .skip_e51:
     # mscratch must be init to zero- we are not using scratch memory
-    csrw mscratch, zero
+   #csrw mscratch, zero
     csrw mcause, zero
     csrw mepc, zero
     /*
diff --git a/src/platform/mpfs_hal/startup_gcc/system_startup.c b/src/platform/mpfs_hal/startup_gcc/system_startup.c
index accd9ea..f4ffd54 100644
--- a/src/platform/mpfs_hal/startup_gcc/system_startup.c
+++ b/src/platform/mpfs_hal/startup_gcc/system_startup.c
@@ -105,7 +105,7 @@ __attribute__((weak)) int main_first_hart(void)
         hard_idx = MPFS_HAL_FIRST_HART + 1U;
         while( hard_idx <= MPFS_HAL_LAST_HART)
         {
-            uint32_t wait_count;
+            uint32_t wait_count=0;
 
             switch(sm_check_thread)
             {
